### Day 1
#### Next.js
> React.js 전용의 웹 개발 프레임워크

#### 사전 렌더링
> 브라우저의 요청에 사전에 렌더링이 완료된 HTML을 응답하는 렌더링 방식

- React App의 장점 승계
  : 빠른 페이지 이동
- React App의 단점 해소(`Client Side Rendering`의 단점을 효율적으로 해결)
  : 빠른 FCP 달성

#### Client Side Rendering의 단점
- FCP(초기 접속 속도)가 느리다.

#### FCP(First Contentful Paint)
> 웹페이지가 로딩을 시작한 시점부터 페이지의 첫 번째 콘텐츠가 화면에 렌더링될 때까지 걸리는 시간을 측정하는 성능 지표

### Day 2
#### Page Router
- 현재 많은 기업에서 사용되고 있는 안정적인 라우터
- React Router처럼 페이지 라우팅 기능을 제공
- Page 폴더의 구조를 기반으로 페이지 라우팅 제공

#### Catch-all Segment
> 지정된 경로 아래의 모든 경로 세그먼트를 동적으로 처리하는 역할을 한다.

`[...id].tsx`
- 최소 하나의 세그먼트가 있어야 매칭된다. 즉, `~/book` 경로 자체는 대응되지 않는다.
- `~/book/1`, `~/book/2`, `~/book/1/2/3` 등과 같은 모든 하위 경로에 대해서 매칭된다.

#### Optional Catch-all Segment
> Catch-all Segment와 거의 동일하지만 경로 세그먼트가 없어도 매칭된다는 한 가지 중요한 차이점이 있다.

`[[...id]].tsx`
- 최소 하나의 세그먼트가 없어도 매칭된다. 즉, `~/book` 경로 자체도 대응된다.
- `~/book/1`, `~/book/2`, `~/book/1/2/3` 등과 같은 모든 하위 경로에 대해서 매칭된다.

### Day 3
#### Navigating
``` ts
import { useRouter } from "next/router";

// useRouter 훅을 사용하여 라우터 객체 가져오기
const router = useRouter();

// 페이지 이동
router.push("/test");
```
- `replace`: 뒤로 가기 방지하며 페이지 이동
- `back`: 페이지를 뒤로 이동

#### Prefetching
> 사용자가 특정 페이지로 이동하기 전에 해당 페이지에서 필요한 리소스를 미리 다운로드하는 기능

1. `<Link>` 컴포넌트를 이용한 자동 프리페칭
- 해당 링크가 뷰포트에 들어오는 순간 해당 페이지에 대한 JS 번들을 백그라운드에서 미리 가져온다.
- `<Link>` 컴포넌트는 기본적으로 `prefetch` 속성이 `true`로 설정되어 있다. 따라서 별도의 설정을 하지 않아도 프리페칭이 자동으로 실행된다.

```ts
import Link from 'next/link';

// 이 링크가 화면에 보이면, /about 페이지의 JS 번들을 미리 다운로드합니다.
<Link href="/about">
  <a>About Us</a>
</Link>
```

2. 수동 프리페칭
- `prefetch` 속성을 `false`로 설정하여 자동 프리페칭을 비활성화할 수 있다.
- 수동으로 프리페칭을 제어해야 할 경우 `router.prefetch()`메서드를 사용할 수도 있다.

#### API Routes
> Next.js에서 API를 구축할 수 있게 해주는 기능
- `http://localhost:3000/api/hello` - `src/pages/api/hello.ts`
- `http://localhost:3000/api/time` - `src/pages/api/time.ts`
#### Styling
`index.css` 파일 생성 후 `index.tsx`에서 import 했을 때 발생하는 오류
- 오류 내용: 전역 CSS는 `_app.tsx`에서만 import할 수 있다.

CSS module: CSS 파일을 모듈화하여 컴포넌트 단위로 스타일을 적용할 수 있는 기능
- 클래스 이름이 고유하게 생성되어 스타일 충동을 방지한다.

`index.css` 대신에 `index.module.css` 파일을 생성해야 한다.

### Day 4
```ts
// src/pages/_app.tsx
import GlobalLayout from "@/components/global-layout";
import "@/styles/globals.css";
import { NextPage } from "next";
import type { AppProps } from "next/app";
import { ReactNode } from "react";

// 새로운 타입 정의: Next.js의 기본 페이지 타입 NextPage를 확장
// &(intersection type): 두 타입을 결합하여 새로운 타입을 만든다.
type NextPageWithLayout = NextPage & {
  getLayout?: (page: ReactNode) => ReactNode;
};

// AppProps의 Component 속성을 직접 정의한 NextPageWithLayout 타입으로 덮어씀
export default function App({
  Component,
  pageProps,
}: AppProps & {
  Component: NextPageWithLayout;
}) {
  // ??: null 또는 undefined일 때만 오른쪽 피연산자 반환, 그 외의 경우에는 왼쪽 피연산자 반환
  const getLayout = Component.getLayout ?? ((page: ReactNode) => page);

  return <GlobalLayout>{getLayout(<Component {...pageProps} />)}</GlobalLayout>;
}

```

```ts
// src/pages/index.tsx
export default function Home() {
  ...
}

// Home 컴포넌트를 렌더링할 때 <SearchableLayout> 컴포넌트로 감싸기
Home.getLayout = (page: ReactNode) => {
  return <SearchableLayout>{page}</SearchableLayout>;
};

```
### Day 5
한입북스 UI 구현

- `word-break`: 텍스트가 콘텐츠 박스를 벗어날 때 줄바꿈이 일어날지 여부를 설정
- `white-space`: 요소 안의 공백을 어떻게 처리할지 설정